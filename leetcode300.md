---
title: "最长递增子序列"
date: 2021-04-01
publishdate: 2021-04-01
lastmod: 2021-04-01
draft: false
tags: ["Algorithm"]
---

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1
```

``` java
/*
时间复杂度,这里应该是O(n^2)
空间复杂度,额外空间O(n)
*/

class Solution {
    public int lengthOfLIS(int[] nums) {
        //记录之前序列的长度
        int[] present = new int[nums.length];
        //所有元素至少出现一次
        for(int i = 0; i < present.length; i++) {
            present[i] = 1;
        }
        
        int res = 0;
        //2,5,3,7
        //主要思路是,每到一个新的点，遍历前面的节点的长度，得到自己当前这个序列的长度
        //把自己当前的这个递增长度记下来，让后面的节点也能用到
        for(int i = 0; i < nums.length; i++) {
            // 迭代1 : value 5
            // 迭代2 : value 3
            for(int j = 0; j < i; j++) {
                //迭代1 : j=2，比5小,j前面没有小的
                //迭代2-1 : j=2,比3小,j前面没有小的
                //迭代2-2 : j=5,比3大,continue,所以迭代2结束,3这里记录的长度也是2
                //迭代3-1 : j=2 ...
                //迭代3-2 : j=5 ...
                //迭代3-3 : j=3 ...
                if(nums[j] < nums[i]) {
                    //迭代1 : 第一个序列, [2,5],长度记录在5这里，长度是2
                    //迭代2-1 : 第二个序列, [2,3],长度记录在3这里，长度也是2
                    //迭代3-1: 第三个序列, [2,7],长度记录在7这里，长度也是2
                    //迭代3-2: 第四个序列, [2,5,7],5这里记录了一个长度2,再加上7,长度3
                    //迭代3-3: 第五个序列, [2,3,7],3这里记录了一个长度2，再加上7，长度3
                    //因为[2,5,3]不是一个序列，所以没有进到这里记录长度，不会出现[2,5,3,7]长度4
                    present[i] = Math.max(present[i],present[j]+1);
                }
            }
        }

        for(int i = 0; i < present.length; i++){
            res = Math.max(res,present[i]);
        }

        return res;
    }
}
```